{"version":3,"sources":["common/notify-binding-behavior.js"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAQ,kB,mBAAA,Y;;AACA,Y,+BAAA,M;;;uCAGK,qB,WADZ,OAAO,YAAP,C;AAGC,uCAAY,YAAZ,EAA0B;AAAA;;AACxB,eAAK,YAAL,GAAoB,YAApB;AACD;;wCAED,I,iBAAK,O,EAAS,K,EAAO,M,EAAQ,S,EAAW;AACtC,cAAI,CAAC,QAAQ,YAAb,EAA2B;;AAG3B,cAAI,iBAAiB,QAAQ,eAAR,CAAwB,WAAxB,CAAoC,QAAQ,MAA5C,EAAoD,QAAQ,cAA5D,CAArB;AACA,kBAAQ,cAAR,GAAyB,cAAzB;AACA,yBAAe,eAAf,GAAiC,QAAQ,cAAR,CAAuB,OAAxD;AACA,cAAI,UAAU,KAAK,YAAL,CAAkB,oBAAlB,CAAuC,CAAC,MAAD,CAAvC,CAAd;AACA,yBAAe,OAAf,GAAyB,OAAzB;;AAEA,cAAI,aAAa,UAAU,QAAQ,MAAR,CAAe,cAA1C;AACA,cAAI,QAAQ,aAAa,QAAQ,gBAAR,CAAyB,UAAzB,CAAoC,IAA7D;AACA,cAAI,YAAY,QAAQ,YAAxB;;AAIA,kBAAQ,0BAAR,IAAsC,SAAtC;AACA,kBAAQ,YAAR,GAAuB,UAAS,KAAT,EAAgB;AAErC,gBAAI,WAAW,GAAX,IAAkB,WAAW,OAAjC,EAA0C;AAIxC,yBAAW;AAAA,uBACT,WAAW,OAAX,CAAmB,IAAnB,CAAwB,UAAxB,EAAoC,QAApC,EAA8C,EAAE,OAAO,KAAT,EAA9C,CADS;AAAA,eAAX,EAEA,GAFA;;AAIA,kBAAI,WAAW,KAAX,KAAqB,KAAzB,EAAgC;AAC9B,2BAAW,KAAX,GAAmB,IAAnB;AACD;AACF;;AAED,mBAAO,UAAU,IAAV,CAAe,OAAf,EAAwB,KAAxB,CAAP;AACD,WAhBD;AAiBD,S;;wCAED,M,mBAAO,O,EAAS,K,EAAO;AACrB,cAAI,CAAC,QAAQ,0BAAR,CAAL,EAA0C;;AAE1C,kBAAQ,YAAR,GAAuB,QAAQ,0BAAR,CAAvB;AACA,kBAAQ,0BAAR,IAAsC,IAAtC;AACD,S","file":"common/notify-binding-behavior.js","sourceRoot":"/source/","sourcesContent":["import {EventManager} from 'aurelia-binding';\r\nimport {inject} from 'aurelia-dependency-injection';\r\n\r\n@inject(EventManager)\r\nexport class NotifyBindingBehavior {\r\n\r\n  constructor(eventManager) {\r\n    this.eventManager = eventManager;\r\n  }\r\n\r\n  bind(binding, scope, target, fieldName) {\r\n    if (!binding.updateSource) return;\r\n\r\n    // update values on blur event\r\n    let targetObserver = binding.observerLocator.getObserver(binding.target, binding.targetProperty);\r\n    binding.targetObserver = targetObserver;\r\n    targetObserver.originalHandler = binding.targetObserver.handler;\r\n    let handler = this.eventManager.createElementHandler(['blur']);\r\n    targetObserver.handler = handler;\r\n\r\n    let observable = target || binding.source.bindingContext;\r\n    let field = fieldName || binding.sourceExpression.expression.name;\r\n    let intercept = binding.updateSource;\r\n\r\n    // intercept updateSource function\r\n    // to call .trigger('change', { field: field}) and set the dirty flag\r\n    binding['intercepted-updateSource'] = intercept;\r\n    binding.updateSource = function(value) {\r\n      // handle change\r\n      if (observable.set && observable.trigger) {\r\n        // kendo recompiles templates after a change event\r\n        // without this delay Aurelia's binding system gets confused as\r\n        // some views are destroyed\r\n        setTimeout(() =>\r\n          observable.trigger.call(observable, 'change', { field: field }),\r\n        100);\r\n\r\n        if (observable.dirty === false) {\r\n          observable.dirty = true;\r\n        }\r\n      }\r\n\r\n      return intercept.call(binding, value);\r\n    };\r\n  }\r\n\r\n  unbind(binding, scope) {\r\n    if (!binding['intercepted-updateSource']) return;\r\n\r\n    binding.updateSource = binding['intercepted-updateSource'];\r\n    binding['intercepted-updateSource'] = null;\r\n  }\r\n}\r\n"]}